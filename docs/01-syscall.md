# 01: システムコール

## システムコールとは
今日では、あらゆるアプリケーションが一つのハードウェアを共有しながら、一つのOSの上で平行、あるいは並列に実行されています。各プログラムは主記憶装置にロードされ、プロセスとしてOSに管理されています。例えば、ZOOMでオンラインミーティングをしながら、Chromeでブラウジングができるのはこのような機能のためです。

しかし、このような状況では、あるプロセスが他のプロセスを書き換えてしまったり、OSのカーネルを破壊してしまう可能性があります。危険なハードウェアの操作によって、コンピュータが物理的に破壊されてしまうかもしれません。そこで、CPUの機能を活用して、プロセスができることを制限し、他のプロセスやカーネルから隔離するようになっているOSが多く存在します。

ここで、普段プロセスが実行されている環境をユーザーモード、カーネルが実行される環境をカーネルモードとよく呼ばれています。（諸説あり） 命令セットによって厳密な名前は違いますが、多くのCPUには、特権モードとしてこれを可能にする機能が実装されています。

ユーザーモードでは、ハードウェアの制御命令や、所定のメモリ領域へのアクセス、システムにかかわるレジスタの読み書きなどがCPUによって制限されます。もし、プロセスの実行中にCPUがそのような命令を読み取ると、例外を発生させ、カーネルに処理を移譲します。

つまり、ユーザーモードで動作しているプロセスは、自力でハードウェアを直接制御することができません。
そこでOSは、ファイル操作やネットワーク通信といった特権的な処理を、**「システムコール」**という安全なインターフェースとしてアプリケーションに提供しています。
アプリケーションはこれらの処理が必要になると、OSに対してシステムコールを発行します。

システムコールが呼び出されると、CPUはユーザーモードからカーネルモードへ移行し、処理がカーネルに移譲されます。そして、カーネルが処理を完了させると、CPUは再びユーザーモードに戻り、アプリケーションは中断した箇所から実行を再開するようになっています。

具体例でいうと、コンソールへの入出力、ファイルの読み書き、ネットワーク機能、画面の描画などなどのあらゆる処理がシステムコールを通して行われます。

注: 以上の理由から、ユーザー空間とカーネル空間の切り替え処理は頻繁に発生するオーバーヘッドであり、これを改善する取り組みが行われています。

## 代表的なシステムコール
代表的なシステムコールには以下のようなものがあります。

- read
- write
- open
- close
- fork
- exec
- socket
- listen
- accept

## システムコールのマニュアルの引き方
各システムコールにはマニュアルが用意されていて、以下のコマンドで表示することができます。

```
man 2 <システムコール名>
```

例えば、readのマニュアルを表示するには以下のようにします:
```
man 2 read
```

また、インターネット上には、マニュアルの日本語訳も存在しています。
[readの日本語マニュアル](https://manpages.ubuntu.com/manpages/jammy/ja/man2/read.2.html)

## strace
straceは、プログラムが利用しているシステムコールを調べるツールです。実際にプログラムを実行して、どんなシステムコールが呼ばれているのかを調べることができます。

Debian系では以下のようにインストールします:
```
sudo apt-get install strace
```


### 実践 1-1: hello worldプログラムの調査

リポジトリのsrc/hello.cに、以下のような標準的なhello worldプログラムを用意しました。

```
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

このプログラムが、どのようなシステムコールを使って、コンソールにhello worldと出力しているのかを調べてみましょう。

コンパイルして、以下のように実行します: 
```
strace ./hello
```

## read/write

readとwriteは、Unix系OSにおけるもっとも基本的なシステムコールの一つで、ファイルに対して読み書きを行います。

### read
readは、ファイルディスクリプタから指定のバッファへ指定のサイズ分のデータを読み込みます。

```
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t count);
```

第１引数には、ファイルディスクリプタを指定します。ファイルディスクリプタについては後述します。

第２引数には、バッファへのポインタを指定します。

第３引数には、バッファに読み込むサイズをバイト単位で指定します。

正常に読み込めた場合は、読み込めたバイト数を返します。これは、必ずしもバッファサイズと一致しないことに注意する必要があります。

ファイルの終端へ到達した場合は０を返します。ファイルのすべての内容を読み込むには、０が帰るまで繰り返しreadを呼び出す必要があります。

エラーが発生した場合は-1を返します。

同じファイルディスクリプタに対して繰り返しreadを実行する場合、読み込み位置が移動します。例えば、１０バイトのファイルに対して５バイト読み込んだ場合、次のreadは６バイト目から読み込みを始めます。

### write
writeは、指定のバッファから指定のサイズ分、ファイルディスクリプタに対して書き込みます。

```
#include <unistd.h>

ssize_t write(int fd, const void *buf, size_t count);
```

第１引数にはファイルディスクリプタを、第２引数には書き込むデータへのポインタを、第３引数には書き込むサイズをバイト単位で指定します。書き込むデータのサイズと第３引数が異なると、余計なメモリ領域のデータが書き込まれてしまったり、十分なデータが書き込まれないことがあるため、注意が必要です。

正常に書き込まれた場合は、書き込まれたサイズをバイト単位で返します。０は、何も書き込まれなかったことを表します。

エラーが発生した場合は、-1を返します。

### ファイルディスクリプタについて
OSは、プロセスが使用しているファイルの情報を**ファイルディスクリプタテーブル**で管理しています。**ファイルディスクリプタ**は、各ファイルディスクリプタのエントリに対応しています。

例えば、OSがreadシステムコールを受けると、指定されたファイルディスクリプタを使ってファイルディスクリプタテーブルからファイル情報を取得し、ファイルに対して処理をします。

実は、ファイルディスクリプタが表すファイルは、入出力ができれば何でも構いません。それは、ディスク上に存在するファイル化もしれませんし、何らかのデバイスかもしれませんし、コンソールへの入出力かもしれません。ネットワークとつながっているソケットかもしれませんが、ファイルディスクリプタを利用するシステムコールはこのようなファイルの種類を全く考慮しません。どんなファイルでも、共通のread/writeが利用できます。

さまざまなファイルのファイルディスクリプタを割り当てるために、openやsocketなどのシステムコールが用意されています。

### 特殊なファイルディスクリプタ

Unix系OSには、OSによって割り当てられている特別なファイルディスクリプタがあります。それが以下の三つです:

- 0: 標準入力
- 1: 標準出力
- 2: 標準エラー出力

標準入力は、コンソールからの入力を読み取ります。標準出力は、コンソールへの出力を書き込みます。標準エラー出力は、コンソールへの出力ですが、エラーメッセージを出力するときに利用します。

そのため、printfやscanfを利用しなくても、read/writeを使って直接コンソールに入出力を行うことができます。

## 実践 1-2: altechoプログラムの作成
echoは、引数に与えられたデータをそのまま標準出力するコマンドです。これに倣って、標準入力から受け取ったデータをそのまま返すプログラムを作成してください。EOF（CTRL+D）が贈られるまで処理を繰り返し、EOFが送られたらプログラムを終了してください。EOFはreadの返り値が0になることで確認できます。

## open

openは、指定したパスのファイルを開き、ファイルディスクリプタを返します。書式は以下の通りです。

```
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

第１引数には、開きたいファイルのパスを指定します。

第２引数には、フラグを指定します。アクセスモードとして、以下のいずれかを指定する必要があります。

- O_RDONLY: 読み込み専用
- O_WRONLY: 書き込み専用
- O_RDWR: 読み書き用

また、追加で以下のようなフラグも指定することができます。その場合、or(|)演算を用います。多くのフラグがあるので、ここでは一部だけを記します。すべてを知りたい場合はマニュアルを参照してください。

- O_CREAT: ファイルが存在しなかった場合はファイルを作成する
- O_APPEND: ファイルを追加(append)モードでopenする

第３引数には、第２引数にO_CREATなどが指定されていた場合に作成されるファイルのpermissionを指定します。指定方法については、chmodコマンドと同様の物が利用できます。

O_CREATを指定しなかった場合、第３引数を指定する必要はありません。

openが成功した場合は、新しいファイルディスクリプタが返ってきます。エラーが発生すると返り値は-1になります。

### close
プログラム中で開いたファイルは、必ず閉じて開放する必要があります。そのために、closeを利用します。

```
#include <unistd.h>

int close(int fd);
```

基本的に、システムプログラミングでは、明示的に開放処理を行わない限りリソースが解放されることはありません。ヒープ領域に確保した領域や、使ったソケット、開いたファイルなどは、使い終わったら正しく解放してあげる必要があります。これを忘れることを防ぐために、pythonのwith分や、goのdeferのような機能があります。

### 実践 1-3: ファイル内容の表示
test/read_file_test.txtの内容を、EOFまで標準出力に出力するプログラムを作成してください。

### 実践 1-4: altcatプログラムの作成
catコマンドは、引数に指定されたファイルの内容を標準出力に出力するプログラムです。これに倣って、引数に指定されたファイルを、EOFまで標準出力に出力するプログラム「altcat」を作成してください。

指定されたファイルがバイナリデータであっても、忠実に出力するようにしてください。

## バッファオーバーフローの脆弱性
各システムコールや、ポインタを受け取るCの関数は、プログラマがどのような意図でメモリ領域を利用しているのかを知りません。そのため、意図した範囲を超えたメモリ領域に読み書きしてしまう可能性があります。これを、バッファオーバーフローの脆弱性と言います。

例えば、256バイトのバッファに対して、３００バイトのデータをreadで読み込もうとすると、バッファオーバーフローが発生します。このような単純なミスはコンパイラが指摘してくれますが、もっと複雑な場合もあります。

### 考えてみましょう
以下のプログラムは、ファイルの内容を読み込んでprintfでコンソールに出力するものです。このプログラムには、バッファオーバーフローの脆弱性があります。どこに問題があって、どのようにすれば改善できるのか考えてみましょう。

```
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main(void) {
    char buffer[16];
    int fd;

    fd = open("data.txt", O_RDONLY);
    if (fd == -1) {
        printf("エラー: data.txt を開けません。\n");
        return 1;
    }

    read(fd, buffer, 16);

    close(fd);

    printf("data: ");
    printf("%s", buffer);
    printf("]\n");

    printf("プログラムが終了しました。\n");

    return 0;
}
```


## EX1: すべてはファイルである
Unixの設計思想には、すべてがファイルである（everything-is-a-file）というものがあります。Unix系のOSでは、あらゆるものがファイルとして扱われます。例えば以下のようなものです:
- ディレクトリ
- デバイス（ディスクを含む）
- ネットワークソケット
- プロセスの状態

Linuxの場合、デバイスファイルは、/dev配下に置かれています。

例えば、以下のようにすると、１０文字のランダムなパスワードを生成することができます:

```
cat /dev/urandom | base64 | fold -w 10 | head -n 1
```

これは、以下の処理をパイプでつなげたものです。
- /dev/urandomの内容を標準出力に出力する
- base64エンコードする
- １０文字ずつに開業を入れる
- １行目だけを表示する

/dev/urandomは、ランダムな値を無限に出力するデバイスです。デバイスですが、このようにファイルとして利用することができます。

また、環境によって異なりますが、接続されたUSBドライブをマウントする場合には、以下のようなコマンドが利用されます:

```
sudo mount /dev/sdb1 /mnt/external-storage
```

## まとめ
- プロセス
- ユーザー空間とカーネル空間
- システムコール
- man
- readとwrite
- echoコマンド
- open
- catコマンド
- バッファオーバーフロー

